#include <algorithm>
#include <cassert>
#include <cmath>
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <unordered_map>

// Returns a value in the range [0, 128). The value is unbiased if the char is
// randomly generated.
int charToPositiveHalfRange(char character) {
  int value = (static_cast<int>(character) + 128) >> 1;
  assert(value >= 0 && value < 128);
  return value;
}

// Reads a file containing a random source of data into a discretized histogram.
// Each byte is converted to the desired range of [0, 128) for this exercise's
// requirements, then stored into a histogram bin with width <Discretization>.
template<int Discretization>
std::unordered_map<int, int> histogramFromFile(const std::string& filename) {
  std::unordered_map<int, int> histogram;
  std::fstream source_stream;
  source_stream.open(filename, std::fstream::in);
  if (!source_stream.is_open()) {
    throw std::runtime_error(filename + " could not be opened for reading");
  }

  // Absolute maximum number of bytes allowed. This constant provides a safety
  // against reading forever from a stream which doesn't terminate; examples
  // include /dev/random and /dev/urandom.
  const int kMaxBytesToRead = 100000;
  int byte_count = 0;
  while (!source_stream.eof() && byte_count++ < kMaxBytesToRead) {
    char random_data;
    source_stream.read(&random_data, 1);
    int value = charToPositiveHalfRange(random_data);
    int bin = value / Discretization;
    ++histogram[bin];
  }
  
  source_stream.close();
  return histogram;  
}

// Returns the entropy of a discrete distribution, where the distribution is
// generated by reading from a file. <Discretization> provides the width of the
// bins used for storing the randomly-read values after the values have been
// adjusted to [0, 128). The entropy is in bits.
template <typename NumericType, int Discretization>
NumericType entropy(const std::string& file_descriptor) {
  std::unordered_map<int, int> histogram = histogramFromFile<Discretization>(file_descriptor);

  int total_count = std::accumulate(histogram.begin(), histogram.end(), 0,
    [](int current_value, const auto& kv) {
      return current_value + kv.second;
    });

  NumericType entropy = 
      std::accumulate(histogram.begin(),
                      histogram.end(),
                      static_cast<NumericType>(0),
                      [&](NumericType current_sum, const auto& kv) {
                        NumericType probability =
                            static_cast<NumericType>(kv.second) / total_count;
                        return current_sum - probability * log2(probability);
                      });

  return entropy;
}

int main() {
  /*
   *Print out the entropy of a probability distribution over 8 discrete events,
   with event occurrences given by a random source of information. 
   */
  const std::string filename = "/dev/urandom";
  std::cout << filename << " has an entropy of "
            << entropy<float, 8>(filename) << " bits." << std::endl;
}
